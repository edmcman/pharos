% A module for reporting the results of object matching.  This probably won't be used in the
% production tool, but it should be useful for interactive debugging of the Prolog
% infrastructure, and perhaps more importantly, it serves to define what an "answer" is for
% when it comes time to import the results back into OOAnalyzer.

:- if(current_prolog_flag(version_data, xsb(_,_,_,_))).
:- use_module(lists, [length/2]).

% XSB drops into an interactive prompt on a runtime error, which isn't very helpful.  We'd
% prefer to print an error and halt instead.
:- use_module(standard, [error_writeln/1]).
:- dynamic default_user_error_handler/1.
default_user_error_handler(X) :-
    error_writeln(['Aborting due to error: ', X]),halt(1).
:- else.
:- use_module(library(dialect/xsb/timed_call), [timed_call/2]).
:- use_module(library(webstat_control)).
:- endif.

:- include('setup.P').

psolve_no_halt(X) :-
    ws_control(perfchart, [clear,interval(5),start]),
    ws_control(perfchart, marking("Loading data")),
    loadInitialFacts(X),
    (loginfo('Guessing is '), guessingDisabled -> loginfoln('disabled.'); loginfoln('enabled.')),
    (loginfo('Profiling is '), profilingEnabled -> loginfoln('enabled.'); loginfoln('disabled.')),
    (loginfo('RTTI is '), rTTIEnabled -> loginfoln('enabled.'); loginfoln('disabled.')),
    profilingEnabled ->
        (timed_call(solve, [repeating(60000, show_progress)]), reportResults);
    ((solve, reportResults)),
    !.

psolve(X) :- psolve_no_halt(X), halt.

% Cory's no longer sure what we were catching.  But if we need to catch something again, we
% should do it here by wrapping psolve(X) and psolve_no_halt() with some code like:
%
% catch((something), E, somehow_report_error)

% This definition of progress is for when we're NOT running from within OOAnalyzer, which is
% probably the same circumstances where we want this reporting module.
progress(N) :-
  loginfo('There are '), loginfo(N), loginfoln(' known facts.').

% In the OOAnalyzer binary, these are passed to a proper Pharos logging stream.
log(Importance, Message) :-
    (numericLogLevel(Importance, MsgNumber),
     logLevel(LogNumber),
     MsgNumber =< LogNumber
    ) -> writeHex(Message) ; true.
logln(Importance, Message) :-
    (numericLogLevel(Importance, MsgNumber),
     logLevel(LogNumber),
     MsgNumber =< LogNumber
    ) -> writelnHex(Message) ; true.

% ============================================================================================
% The main reporting rule.
% ============================================================================================

writePredicate(P) :-
    writeHexTerm(P),
    writeln('.').

% A strange hybrid case.  We store these as find(C1, C2), but we frequently refer to them in
% our code as factMergeClasses/2, which seems to be the more natural way to express them.  This
% little bit of syntactic sugar should help ease that gap.
reportPredicate(factMergeClasses/2) :-
    forall(find(C1, C2), writePredicate(factMergeClasses(C1, C2))), !.

reportPredicate(Name/Arity) :-
    functor(Head, Name, Arity), forall(Head, writePredicate(Head)), !.

reportResults :-
    reportGuessedStatistics,
    writeln('% Prolog results autogenerated by OOAnalyzer.'),
    reportPredicate(finalFileInfo/2),
    reportPredicate(finalVFTable/5),
    reportPredicate(finalVFTableEntry/3),
    reportPredicate(finalVBTable/4),
    reportPredicate(finalVBTableEntry/3),
    reportPredicate(finalClass/6),
    reportPredicate(finalResolvedVirtualCall/3),
    reportPredicate(finalEmbeddedObject/4),
    reportPredicate(finalInheritance/5),
    reportPredicate(finalMember/4),
    reportPredicate(finalMemberAccess/4),
    reportPredicate(finalMethodProperty/3),
    reportPredicate(finalThunk/2),
    reportPredicate(finalDemangledName/4),
    % Cory would like for this line to go to stderr?
    writeln('% Object detection reporting complete.').

reportMethodFacts :-
    reportPredicate(factMethod/1),
    reportPredicate(factConstructor/1),
    reportPredicate(factRealDestructor/1),
    reportPredicate(factDeletingDestructor/1),
    reportPredicate(factVirtualFunctionCall/5).

reportNOTMethodFacts :-
    reportPredicate(factNOTMethod/1),
    reportPredicate(factNOTConstructor/1),
    reportPredicate(factNOTRealDestructor/1),
    reportPredicate(factNOTDeletingDestructor/1),
    reportPredicate(factNOTVirtualFunctionCall/5).

reportVirtualTableFacts :-
    reportPredicate(factVFTable/1),
    reportPredicate(factVFTableWrite/4),
    reportPredicate(factVFTableOverwrite/4),
    reportPredicate(factVFTableEntry/3),
    reportPredicate(factVFTableSizeGTE/2),
    reportPredicate(factVFTableSizeLTE/2),
    reportPredicate(factVBTable/1),
    reportPredicate(factVBTableWrite/4),
    reportPredicate(factVBTableEntry/3).

reportNOTVirtualTableFacts :-
    reportPredicate(factNOTVFTable/1),
    reportPredicate(factNOTVFTableEntry/3),
    reportPredicate(factNOTVBTable/1),
    reportPredicate(factNOTVBTableEntry/3).

reportClassFacts :-
    reportPredicate(factObjectInObject/3),
    reportPredicate(factDerivedClass/3),
    reportPredicate(factEmbeddedObject/3),
    reportPredicate(factClassHasNoBase/1),
    reportPredicate(factClassHasUnknownBase/1),
    reportPredicate(factClassCallsMethod/2),
    reportPredicate(factClassSizeGTE/2),
    reportPredicate(factClassSizeLTE/2).

reportFacts :-
    reportMethodFacts,
    reportNOTMethodFacts,
    reportVirtualTableFacts,
    reportNOTVirtualTableFacts,
    reportClassFacts,
    reportPredicate(factMergeClasses/2),
    reportPredicate(factNOTMergeClasses/2).

% ============================================================================================
% Rules for counting guesses at the end of execution.
% ============================================================================================

% Woot! Cory figured it out to count arbitary predicates all by himself! ;-)
count(Pred/Arity, N) :-
    functor(OldTerm, Pred, Arity),
    findall(1, OldTerm, L),
    length(L, N).

% Print how many conclusions were guessed versus how many were reasoned.  We could also report
% the actual specific guesssed facts if we wanted.
reportGuessedStatistics :-
    count(guessedMethod/1, GM), count(factMethod/1, FM),
    count(guessedNOTMethod/1, GNM), count(factNOTMethod/1, FNM),
    loginfo('Guessed methods '), loginfo(GM), loginfo(' of '), loginfo(FM),
    loginfo(', NOT: '), loginfo(GNM), loginfo(' of '), loginfoln(FNM),

    count(guessedConstructor/1, GC), count(factConstructor/1, FC),
    count(guessedNOTConstructor/1, GNC), count(factNOTConstructor/1, FNC),
    loginfo('Guessed constructors '), loginfo(GC), loginfo(' of '), loginfo(FC),
    loginfo(', NOT: '), loginfo(GNC), loginfo(' of '), loginfoln(FNC),

    count(guessedRealDestructor/1, GRD), count(factRealDestructor/1, FRD),
    count(guessedNOTRealDestructor/1, GNRD), count(factNOTRealDestructor/1, FNRD),
    loginfo('Guessed real destructors '), loginfo(GRD), loginfo(' of '), loginfo(FRD),
    loginfo(', NOT: '), loginfo(GNRD), loginfo(' of '), loginfoln(FNRD),

    count(guessedDeletingDestructor/1, GDD), count(factDeletingDestructor/1, FDD),
    count(guessedNOTDeletingDestructor/1, GNDD), count(factNOTDeletingDestructor/1, FNDD),
    loginfo('Guessed deleting destructors '), loginfo(GDD), loginfo(' of '), loginfo(FDD),
    loginfo(', NOT: '), loginfo(GNDD), loginfo(' of '), loginfoln(FNDD),

    count(guessedVirtualFunctionCall/5, GVFC), count(factVirtualFunctionCall/5, FVFC),
    count(guessedNOTVirtualFunctionCall/5, GNVFC), count(factNOTVirtualFunctionCall/5, FNVFC),
    loginfo('Guessed virtual function calls '), loginfo(GVFC), loginfo(' of '), loginfo(FVFC),
    loginfo(', NOT: '), loginfo(GNVFC), loginfo(' of '), loginfoln(FNVFC),

    count(guessedVFTable/1, GVFT), count(factVFTable/1, FVFT),
    count(guessedNOTVFTable/1, GNVFT), count(factNOTVFTable/1, FNVFT),
    loginfo('Guessed virtual function tables '), loginfo(GVFT), loginfo(' of '), loginfo(FVFT),
    loginfo(', NOT: '), loginfo(GNVFT), loginfo(' of '), loginfoln(FNVFT),

    count(guessedVBTable/1, GVBT), count(factVBTable/1, FVBT),
    count(guessedNOTVBTable/1, GNVBT), count(factNOTVBTable/1, FNVBT),
    loginfo('Guessed virtual base tables '), loginfo(GVBT), loginfo(' of '), loginfo(FVBT),
    loginfo(', NOT: '), loginfo(GNVBT), loginfo(' of '), loginfoln(FNVBT),

    count(guessedVFTableEntry/3, GVFTE), count(factVFTableEntry/3, FVFTE),
    count(guessedNOTVFTableEntry/3, GNVFTE), count(factNOTVFTableEntry/3, FNVFTE),
    loginfo('Guessed virtual function table entries '), loginfo(GVFTE), loginfo(' of '), loginfo(FVFTE),
    loginfo(', NOT: '), loginfo(GNVFTE), loginfo(' of '), loginfoln(FNVFTE),

    count(guessedDerivedClass/3, GDC), count(factDerivedClass/3, FDC),
    count(guessedNOTDerivedClass/3, GNDC), count(factNOTDerivedClass/3, FNDC),
    loginfo('Guessed derived classes '), loginfo(GDC), loginfo(' of '), loginfo(FDC),
    loginfo(', NOT: '), loginfo(GNDC), loginfo(' of '), loginfoln(FNDC),

    count(guessedEmbeddedObject/3, GEO), count(factEmbeddedObject/3, FEO),
    count(guessedNOTEmbeddedObject/3, GNEO), count(factNOTEmbeddedObject/3, FNEO),
    loginfo('Guessed embedded objects '), loginfo(GEO), loginfo(' of '), loginfo(FEO),
    loginfo(', NOT: '), loginfo(GNEO), loginfo(' of '), loginfoln(FNEO),

    count(guessedClassHasUnknownBase/1, GUBC), count(factClassHasUnknownBase/1, FUBC),
    count(guessedClassHasNoBase/1, GNBC), count(factClassHasNoBase/1, FNBC),
    loginfo('Guessed has a base class '), loginfo(GUBC), loginfo(' of '), loginfo(FUBC),
    loginfo(', NOT: '), loginfo(GNBC), loginfo(' of '), loginfoln(FNBC),

    %% count(guessedMergeClasses/2, GMC), count(factMergeClasses/2, FMC),
    %% count(guessedNOTMergeClasses/2, GNMC), count(factNOTMergeClasses/2, FNMC),
    %% loginfo('Guessed class mergers '), loginfo(GMC), loginfo(' of '), loginfo(FMC),
    %% loginfo(', NOT: '), loginfo(GNMC), loginfo(' of '), loginfoln(FNMC),

    true.

/* Local Variables:   */
/* mode: prolog       */
/* fill-column:    95 */
/* comment-column: 0  */
/* End:               */
